package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var (
	version = "v0.1.2"
	// flags
	pathOnly    bool
	showVersion bool
	showHelp    bool
)

const helpText = `
	gtr - Go To Root - A smart project root navigator

	Usage:
		gtr [options]

	Options:
	-h, --help			Show this help message
	-v, --version		Show version information
	--path-only			Only output the project root path without changing directroy

	Examples:
  gtr           # Navigate to project root
  gtr --version # Show version information

	Project Detection:
		gtr detects project roots using common indicators like:
		- Version Control (.git, .svn)
		- Package Managers (package.json, go.mod)
		- Configuration Files (docker-compose.yml, Makefile)
		- And many others

	For more information, visit: https://github.com/ayoubissaad/gtr
	`

func init() {
	// Create a custom FlagSet to handle both short and long versions
	flag.BoolVar(&pathOnly, "path-only", false, "Only output the project root path")

	// Version flag (short and long form)
	flag.BoolVar(&showVersion, "version", false, "Show version information")
	flag.BoolVar(&showVersion, "v", false, "Show version information") // Short version

	// Help flag (short and long form)
	flag.BoolVar(&showHelp, "help", false, "Show help information")
	flag.BoolVar(&showHelp, "h", false, "Show help information") // Short version

	// Override default usage
	flag.Usage = func() {
		fmt.Fprint(os.Stderr, helpText)
	}
}

// Shell configurations
type ShellConfig struct {
	name         string
	rcFile       string
	wrapperCode  string
	commentStart string
}

var shellConfigs = map[string]ShellConfig{
	"bash": {
		name:         "bash",
		rcFile:       ".bashrc",
		commentStart: "#",
		wrapperCode: `
# gtr wrapper function - Generated by gtr installer v0.1.0
gtr() {
    local dir="$(command gtr --path-only)"
    [[ $? -eq 0 ]] && cd "$dir"
}
`,
	},
	"zsh": {
		name:         "zsh",
		rcFile:       ".zshrc",
		commentStart: "#",
		wrapperCode: `
# gtr wrapper function - Generated by gtr installer v0.1.0
gtr() {
    local dir="$(command gtr --path-only)"
    [[ $? -eq 0 ]] && cd "$dir"
}
`,
	},
	"fish": {
		name:         "fish",
		rcFile:       "config.fish",
		commentStart: "#",
		wrapperCode: `
# gtr wrapper function - Generated by gtr installer v0.1.0
function gtr
    set -l dir (command gtr --path-only)
    if test $status -eq 0
        cd "$dir"
    end
end
`,
	},
}

// Project indicators - files and directories that typically indicate a project root
var rootIndicators = []string{
	// Version Control
	".git",
	".svn",
	".hg",

	// Documentation
	"README.md",
	"README.rst",
	"README",
	"CONTRIBUTING.md",
	"LICENSE",

	// Package Managers
	"package.json",
	"composer.json",
	"go.mod",
	"Cargo.toml",
	"requirements.txt",
	"setup.py",
	"Gemfile",
	"pom.xml",
	"build.gradle",
	"build.gradle.kts",
	"project.clj",
	"mix.exs",

	// Configuration Files
	".env",
	"docker-compose.yml",
	"docker-compose.yaml",
	"Dockerfile",
	"Makefile",
	"CMakeLists.txt",
	".editorconfig",
	"tsconfig.json",
	"next.config.js",
	"vite.config.js",
	"webpack.config.js",
	".eslintrc",
	".eslintrc.js",
	".eslintrc.json",

	// Lock Files
	"yarn.lock",
	"package-lock.json",
	"pnpm-lock.yaml",
	"composer.lock",
	"Cargo.lock",
	"poetry.lock",
	"Pipfile.lock",

	// IDE/Editor Configs
	".vscode",
	".idea",
	".eclipse",
	".project",

	// CI/CD
	".github",
	".gitlab-ci.yml",
	".travis.yml",
	"jenkins.yml",
	"azure-pipelines.yml",

	// Custom Markers
	".root",
	".project-root",
}

// Common project directories that might indicate a root
var rootDirs = []string{
	// Source Code
	"src",
	"lib",
	"pkg",
	"internal",
	"cmd",

	// Documentation
	"docs",
	"documentation",
	"wiki",

	// Testing
	"tests",
	"test",
	"spec",
	"specs",
	"__tests__",

	// Web Development
	"public",
	"static",
	"assets",
	"dist",
	"build",

	// Package Management
	"node_modules",
	"vendor",
	"packages",

	// Scripts
	"scripts",
	"tools",
	"bin",

	// Configuration
	"config",
	"conf",
	"settings",

	// Components
	"components",
	"modules",
	"plugins",

	// API
	"api",
	"endpoints",
	"routes",

	// Database
	"migrations",
	"schemas",
	"database",
}

func main() {
	// Parse command line flags
	flag.Parse()

	// Check for unknown arguments
	if flag.NArg() > 0 {
		fmt.Fprintf(os.Stderr, "Error: Unknown argument '%s'\n", flag.Arg(0))
		flag.Usage()
		os.Exit(1)
	}

	switch {
	case showHelp:
		flag.Usage()
		return
	case showVersion:
		fmt.Printf("gtr version %s\n", version)
		return
	case pathOnly:
		handleNavigation()
		return
	default:
		// Normal execution
		if !isWrapperInstalled() {
			handleFirstRun()
		} else {
			handleNavigation()
		}
	}
}

func handleFirstRun() {
	fmt.Println("Welcome to gtr! ðŸš€")
	fmt.Println("To enable directory navigation, gtr needs to add a small wrapper to your shell configuration.")

	shell := detectShell()
	if shell == "" {
		fmt.Println("\nCouldn't detect your shell automatically. Please add the wrapper manually:")
		printManualInstructions()
		os.Exit(1)
	}

	config, exists := shellConfigs[shell]
	if !exists {
		fmt.Printf("\nYour shell (%s) is not supported. Please add the wrapper manually:\n", shell)
		printManualInstructions()
		os.Exit(1)
	}

	fmt.Printf("\nDetected %s shell. Would you like to automatically add the wrapper to your %s? (y/n): ", shell, config.rcFile)

	reader := bufio.NewReader(os.Stdin)
	response, _ := reader.ReadString('\n')
	response = strings.TrimSpace(strings.ToLower(response))

	if response == "y" || response == "yes" {
		err := installWrapper(config)
		if err != nil {
			fmt.Printf("Error installing wrapper: %v\n", err)
			fmt.Println("\nPlease add the wrapper manually:")
			printManualInstructions()
			os.Exit(1)
		}
		fmt.Printf("\nWrapper installed successfully! Please restart your shell or run:\nsource ~/%s\n", config.rcFile)
	} else {
		fmt.Println("\nOkay! You can add the wrapper manually:")
		printManualInstructions()
	}
}

func handleNavigation() {
	currentDir, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
		os.Exit(1)
	}

	projectRoot, found := findProjectRoot(currentDir)
	if !found {
		fmt.Fprintf(os.Stderr, "No project root found\n")
		os.Exit(1)
	}

	fmt.Println(projectRoot)
}

func findProjectRoot(startDir string) (string, bool) {
	currentDir := startDir

	for {
		// Check for root indicators (files)
		for _, indicator := range rootIndicators {
			path := filepath.Join(currentDir, indicator)
			if fileExists(path) {
				// If we find a root indicator, check if parent also has indicators
				parentDir := filepath.Dir(currentDir)
				if isSubdirectory(parentDir, startDir) && hasRootIndicators(parentDir) {
					return parentDir, true
				}
				return currentDir, true
			}
		}

		// Check for root directories with multiple indicators
		hasMultipleIndicators := false
		for _, dir := range rootDirs {
			path := filepath.Join(currentDir, dir)
			if isDir(path) {
				if hasMultipleProjectIndicators(currentDir) {
					hasMultipleIndicators = true
					break
				}
			}
		}
		if hasMultipleIndicators {
			return currentDir, true
		}

		// Move up one directory
		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			break
		}
		currentDir = parentDir
	}

	return "", false
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func isDir(path string) bool {
	info, err := os.Stat(path)
	return err == nil && info.IsDir()
}

func isSubdirectory(parent, child string) bool {
	rel, err := filepath.Rel(parent, child)
	if err != nil {
		return false
	}
	return !strings.Contains(rel, "..")
}

func hasRootIndicators(dir string) bool {
	for _, indicator := range rootIndicators {
		if fileExists(filepath.Join(dir, indicator)) {
			return true
		}
	}
	return false
}

func hasMultipleProjectIndicators(dir string) bool {
	count := 0
	// Count both files and directories that indicate a project root
	for _, indicator := range rootIndicators {
		if fileExists(filepath.Join(dir, indicator)) {
			count++
		}
	}
	for _, rootDir := range rootDirs {
		if isDir(filepath.Join(dir, rootDir)) {
			count++
		}
	}
	return count >= 2
}

func isWrapperInstalled() bool {
	shell := detectShell()
	if shell == "" {
		return false
	}

	config, exists := shellConfigs[shell]
	if !exists {
		return false
	}

	rcPath := filepath.Join(os.Getenv("HOME"), config.rcFile)
	content, err := os.ReadFile(rcPath)
	if err != nil {
		return false
	}

	return strings.Contains(string(content), "gtr wrapper function")
}

func installWrapper(config ShellConfig) error {
	rcPath := filepath.Join(os.Getenv("HOME"), config.rcFile)

	// Create file if it doesn't exist
	if _, err := os.Stat(rcPath); os.IsNotExist(err) {
		err = os.WriteFile(rcPath, []byte(config.wrapperCode), 0644)
		return err
	}

	// Read existing content
	content, err := os.ReadFile(rcPath)
	if err != nil {
		return err
	}

	// Remove any existing gtr wrapper
	lines := strings.Split(string(content), "\n")
	var newLines []string
	inWrapper := false

	for _, line := range lines {
		if strings.Contains(line, "gtr wrapper function") {
			inWrapper = true
			continue
		}
		if inWrapper {
			if strings.TrimSpace(line) == "" {
				inWrapper = false
				continue
			}
			continue
		}
		newLines = append(newLines, line)
	}

	// Add new wrapper
	newContent := strings.Join(newLines, "\n") + config.wrapperCode

	return os.WriteFile(rcPath, []byte(newContent), 0644)
}

func detectShell() string {
	shell := os.Getenv("SHELL")
	shell = strings.ToLower(shell)

	switch {
	case strings.Contains(shell, "bash"):
		return "bash"
	case strings.Contains(shell, "zsh"):
		return "zsh"
	case strings.Contains(shell, "fish"):
		return "fish"
	default:
		return ""
	}
}

func printManualInstructions() {
	fmt.Println("\nBash/Zsh users - Add to ~/.bashrc or ~/.zshrc:")
	fmt.Println(shellConfigs["bash"].wrapperCode)

	fmt.Println("\nFish users - Add to ~/.config/fish/config.fish:")
	fmt.Println(shellConfigs["fish"].wrapperCode)
}
